//! Backend for Huff code generation
//! 
//! This module provides the backend for generating Huff code from Lamina IR.

use lamina_ir::ir::{Program, Def, Expr, Type, BinOp, UnOp};
use crate::{Result, HuffError};

/// A backend that generates Huff code
pub struct HuffBackend {
    /// Generated Huff code
    code: String,
    
    /// Defined macros
    macros: Vec<String>,
    
    /// Defined constants
    constants: Vec<String>,
}

impl HuffBackend {
    /// Create a new Huff backend
    pub fn new() -> Self {
        Self {
            code: String::new(),
            macros: Vec::new(),
            constants: Vec::new(),
        }
    }
    
    /// Generate Huff code from a program
    pub fn generate(&mut self, program: &Program) -> Result<String> {
        // Reset the backend
        self.code.clear();
        self.macros.clear();
        self.constants.clear();
        
        // Add header comment
        self.code.push_str("// Generated by lamina-huff\n\n");
        
        // Process each definition
        for def in &program.defs {
            match def {
                Def::Function { name, params, return_type, body } => {
                    self.generate_function(name.0.as_str(), params, return_type, body)?;
                }
                Def::Const { name, ty, value } => {
                    self.generate_constant(name.0.as_str(), ty, value)?;
                }
                Def::TypeDef { .. } => {
                    // Skip type definitions for now, as they don't generate EVM code
                }
            }
        }
        
        // Add MAIN and CONSTRUCTOR macros
        self.generate_main_macro()?;
        self.generate_constructor_macro()?;
        
        // Combine all parts into the final code
        let mut result = String::new();
        
        // Add constants
        for constant in &self.constants {
            result.push_str(constant);
            result.push('\n');
        }
        result.push('\n');
        
        // Add macros
        for macro_def in &self.macros {
            result.push_str(macro_def);
            result.push_str("\n\n");
        }
        
        // Add the main code
        result.push_str(&self.code);
        
        Ok(result)
    }
    
    /// Generate a function as a Huff macro
    fn generate_function(&mut self, name: &str, params: &[(lamina_ir::ir::Ident, Type)], return_type: &Type, body: &Expr) -> Result<()> {
        // Calculate takes/returns values based on params and return type
        let takes = params.len();
        let returns = if matches!(return_type, Type::Unit) { 0 } else { 1 };
        
        // Start macro definition
        let macro_def = format!("#define macro {}() = takes({}) returns({}) {{\n", 
                              name.to_uppercase(), takes, returns);
        
        // In a real implementation, we would recursively generate code for the body
        // For now, just add a placeholder
        let mut macro_body = String::new();
        macro_body.push_str("    // Function body placeholder\n");
        macro_body.push_str("    0x00 0x00 return\n");
        
        // Close macro definition
        let macro_def = format!("{}{}}}", macro_def, macro_body);
        
        // Add to the list of macros
        self.macros.push(macro_def);
        
        Ok(())
    }
    
    /// Generate a constant
    fn generate_constant(&mut self, name: &str, ty: &Type, value: &Expr) -> Result<()> {
        // Convert constant to a define statement
        // In a real implementation, we would evaluate the expression
        // For now, just add a placeholder
        let constant_def = format!("#define {} 0x00", name.to_uppercase());
        
        // Add to the list of constants
        self.constants.push(constant_def);
        
        Ok(())
    }
    
    /// Generate the main macro
    fn generate_main_macro(&mut self) -> Result<()> {
        // Start main macro definition
        let macro_def = format!("#define macro MAIN() = takes(0) returns(0) {{\n");
        
        // Add placeholder code
        let mut macro_body = String::new();
        macro_body.push_str("    // Main function\n");
        macro_body.push_str("    0x00 calldataload 0xe0 shr    // Get function selector\n\n");
        
        // Add function dispatch logic
        macro_body.push_str("    // Function dispatch\n");
        
        // In a real implementation, we would add dispatch for each function
        // For now, just add fallback logic
        macro_body.push_str("    // Fallback\n");
        macro_body.push_str("    0x00 0x00 return\n");
        
        // Close macro definition
        let macro_def = format!("{}{}}}", macro_def, macro_body);
        
        // Add to the list of macros
        self.macros.push(macro_def);
        
        Ok(())
    }
    
    /// Generate the constructor macro
    fn generate_constructor_macro(&mut self) -> Result<()> {
        // Start constructor macro definition
        let macro_def = format!("#define macro CONSTRUCTOR() = takes(0) returns(0) {{\n");
        
        // Add placeholder code
        let mut macro_body = String::new();
        macro_body.push_str("    // Constructor code\n");
        macro_body.push_str("    // Deploy runtime code\n");
        macro_body.push_str("    MAIN()\n");
        
        // Close macro definition
        let macro_def = format!("{}{}}}", macro_def, macro_body);
        
        // Add to the list of macros
        self.macros.push(macro_def);
        
        Ok(())
    }
} 