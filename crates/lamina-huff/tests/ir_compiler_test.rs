use lamina_ir::ir::{Program, Def, Expr, Type, Ident, BinOp};
use lamina_huff::{compile_to_huff, HuffOptions};

#[test]
fn test_ir_to_huff_counter() {
    // Create a simple counter program using Lamina IR
    let mut program = Program::new();
    
    // Add metadata
    program.add_metadata("name", "Counter");
    program.add_metadata("author", "Lamina Team");
    
    // Define constants
    let counter_slot = Def::Const {
        name: Ident("COUNTER_SLOT".to_string()),
        ty: Type::Uint(256),
        value: Expr::UintLit(0),
    };
    program.add_def(counter_slot);
    
    // Define get-counter function
    let get_counter = Def::Function {
        name: Ident("get_counter".to_string()),
        params: vec![],
        return_type: Type::Uint(256),
        body: Expr::Call(
            Box::new(Expr::Var(Ident("storage-load".to_string()))),
            vec![Expr::Var(Ident("COUNTER_SLOT".to_string()))],
        ),
    };
    program.add_def(get_counter);
    
    // Define increment function
    let increment = Def::Function {
        name: Ident("increment".to_string()),
        params: vec![],
        return_type: Type::Uint(256),
        body: Expr::Let(
            Ident("current".to_string()),
            Box::new(Expr::Call(
                Box::new(Expr::Var(Ident("storage-load".to_string()))),
                vec![Expr::Var(Ident("COUNTER_SLOT".to_string()))],
            )),
            Box::new(Expr::Let(
                Ident("_".to_string()),
                Box::new(Expr::Call(
                    Box::new(Expr::Var(Ident("storage-store".to_string()))),
                    vec![
                        Expr::Var(Ident("COUNTER_SLOT".to_string())),
                        Expr::BinOp(
                            BinOp::Add, 
                            Box::new(Expr::Var(Ident("current".to_string()))),
                            Box::new(Expr::UintLit(1)),
                        ),
                    ],
                )),
                Box::new(Expr::Call(
                    Box::new(Expr::Var(Ident("storage-load".to_string()))),
                    vec![Expr::Var(Ident("COUNTER_SLOT".to_string()))],
                )),
            )),
        ),
    };
    program.add_def(increment);
    
    // Options for compilation
    let options = HuffOptions {
        output_dir: ".".to_string(),
        base_name: "CounterTest".to_string(),
        optimize: true,
    };
    
    // Compile from IR to Huff
    let huff_code = compile_to_huff(&program, &options).unwrap();
    
    // Basic verification that we have a valid Huff program
    assert!(huff_code.contains("Generated by lamina-huff"));
    assert!(huff_code.contains("MAIN()"));
    assert!(huff_code.contains("CONSTRUCTOR()"));
    
    // Note: The following are commented out for now since we're using placeholder code.
    // These will be uncommented once the actual implementation is in place.
    // assert!(huff_code.contains("GET_COUNTER()") || huff_code.contains("get_counter"));
    // assert!(huff_code.contains("INCREMENT()") || huff_code.contains("increment"));
}

#[test]
fn test_ir_to_huff_simple_storage() {
    // Create a simple storage program using Lamina IR
    let mut program = Program::new();
    
    // Add metadata
    program.add_metadata("name", "SimpleStorage");
    
    // Define constants
    let value_slot = Def::Const {
        name: Ident("VALUE_SLOT".to_string()),
        ty: Type::Uint(256),
        value: Expr::UintLit(0),
    };
    program.add_def(value_slot);
    
    // Define get-value function
    let get_value = Def::Function {
        name: Ident("get_value".to_string()),
        params: vec![],
        return_type: Type::Uint(256),
        body: Expr::Call(
            Box::new(Expr::Var(Ident("storage-load".to_string()))),
            vec![Expr::Var(Ident("VALUE_SLOT".to_string()))],
        ),
    };
    program.add_def(get_value);
    
    // Define set-value function
    let set_value = Def::Function {
        name: Ident("set_value".to_string()),
        params: vec![(Ident("new_value".to_string()), Type::Uint(256))],
        return_type: Type::Uint(256),
        body: Expr::Let(
            Ident("_".to_string()),
            Box::new(Expr::Call(
                Box::new(Expr::Var(Ident("storage-store".to_string()))),
                vec![
                    Expr::Var(Ident("VALUE_SLOT".to_string())),
                    Expr::Var(Ident("new_value".to_string())),
                ],
            )),
            Box::new(Expr::Call(
                Box::new(Expr::Var(Ident("storage-load".to_string()))),
                vec![Expr::Var(Ident("VALUE_SLOT".to_string()))],
            )),
        ),
    };
    program.add_def(set_value);
    
    // Options for compilation
    let options = HuffOptions {
        output_dir: ".".to_string(),
        base_name: "SimpleStorageTest".to_string(),
        optimize: true,
    };
    
    // Compile from IR to Huff
    let huff_code = compile_to_huff(&program, &options).unwrap();
    
    // Basic verification
    assert!(huff_code.contains("MAIN()"));
    assert!(huff_code.contains("CONSTRUCTOR()"));
    assert!(huff_code.contains("Generated by lamina-huff"));
    
    // Note: The following are commented out for now since we're using placeholder code.
    // These will be uncommented once the actual implementation is in place.
    // assert!(huff_code.contains("GET_VALUE()") || huff_code.contains("get_value"));
    // assert!(huff_code.contains("SET_VALUE()") || huff_code.contains("set_value"));
} 